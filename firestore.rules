
/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a role-based access control model with ownership constraints, leveraging denormalization for authorization independence.
 *
 * Data Structure:
 * - /roles_admin/{uid}: Documents representing admin users. Existence implies admin role.
 * - /users/{userId}: User profiles (admin, faculty, student).
 * - /users/{facultyId}/classes/{classId}: Mirrored class data for faculty ownership.
 * - /users/{studentId}/attendance/{attendanceId}: A student's attendance records.
 * - /classes/{classId}: Root collection for all classes, allowing easier querying.
 * - /classes/{classId}/students/{studentId}: Students enrolled in a class. Includes denormalized class data.
 * - /classes/{classId}/attendance/{attendanceId}: Attendance records for a class.
 *
 * Key Security Decisions:
 * - Admin role is determined by the existence of a document in /roles_admin/{uid}.
 * - Faculty can only manage classes under their own /users/{facultyId} path.
 * - Root-level '/classes' allows admins to list all classes and students to find their classes (with proper queries).
 * - Students can only be added or managed within a class by the owning faculty member.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user has the admin role.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }
    
    /**
     * @description Checks if the user has the faculty role from their user profile document.
     */
    function isFaculty() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'faculty';
    }

    /**
     * @description Checks if the user is the faculty owner of a specific class.
     * It verifies ownership by checking the 'facultyId' on the class document itself.
     */
    function isClassOwner(classId) {
        let classData = get(/databases/$(database)/documents/classes/$(classId)).data;
        return isSignedIn() && classData.facultyId == request.auth.uid;
    }
    
    // Admins can manage admin roles. Only creation is allowed to prevent accidental deletion/update.
    match /roles_admin/{uid} {
      allow get: if false; // No one can read the full list of admins.
      allow list: if false;
      allow create: if isOwner(uid) && request.resource.data.role == 'admin';
      allow update, delete: if false; // Roles must be managed manually or via backend for safety.
    }

    // Admins can manage all users. Users can read/update their own profile.
    match /users/{userId} {
      allow get: if isAdmin() || isOwner(userId);
      allow list: if isAdmin(); // Only admins can list all users.
      allow create: if isAdmin(); // Only admins can create users via the UI.
      allow update: if isAdmin() || isOwner(userId);
      allow delete: if isAdmin();

      // Students can read their own attendance, faculty can read/write for their students.
      match /attendance/{attendanceId} {
        allow read: if isOwner(userId) || isAdmin() || isClassOwner(resource.data.classId);
        allow write: if isAdmin() || isClassOwner(resource.data.classId);
      }
    }
    
    // Faculty can manage the classes listed under their own profile. This enforces ownership.
    match /users/{facultyId}/classes/{classId} {
      allow read, list: if isOwner(facultyId) || isAdmin();
      allow create, update, delete: if isOwner(facultyId) || isAdmin();
    }

    // Rules for the root /classes collection
    match /classes/{classId} {
        // Read: Admins or the owning faculty can read a class doc.
        // Students can read if they are enrolled (checked via subcollection existence).
        allow get: if isAdmin() || isClassOwner(classId) || exists(/databases/$(database)/documents/classes/$(classId)/students/$(request.auth.uid));
        
        // List: Only Admins and Faculty can list classes. 
        // Students should query for their specific classes, not list all of them.
        allow list: if isAdmin() || isFaculty();
        
        // Write: Only Admins or the assigned faculty can create/update/delete.
        allow write: if isAdmin() || isClassOwner(classId);
    }
    
    // Rules for managing students within a class
    match /classes/{classId}/students/{studentId} {
      // Read/List: Admin or the class owner can see the enrolled students.
      // A faculty member needs to list students to enroll them.
      allow read, list: if isAdmin() || isClassOwner(classId);
      
      // Create/Update/Delete: Only the class owner or an admin can manage the roster.
      // We also check that the denormalized classId in the student record matches the path.
      allow write: if (isAdmin() || isClassOwner(classId)) && request.resource.data.classId == classId;
    }

    // Rules for attendance records
    match /classes/{classId}/attendance/{attendanceId} {
      // Read/List: Admin or the class owner can see attendance.
      allow read, list: if isAdmin() || isClassOwner(classId);

      // Write: Only the class owner (faculty) or an admin can create/modify attendance.
      // We also check for data consistency.
      allow write: if (isAdmin() || isClassOwner(classId)) && request.resource.data.classId == classId;
    }

    // Admin-only collection group queries
    match /{path=**}/attendance/{docId} {
      allow get, list: if isAdmin();
    }
  }
}
